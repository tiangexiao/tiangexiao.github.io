<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="最大子数组和股票买卖问题"><meta name="keywords" content="leetcode,动态规划,贪心算法"><meta name="author" content="小舔哥"><meta name="copyright" content="小舔哥"><title>最大子数组和股票买卖问题 | 小舔哥</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#最大子数组问题"><span class="toc-number">1.</span> <span class="toc-text">最大子数组问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#leetcode-121.-best-time-to-buy-and-sell-stock1"><span class="toc-number">2.</span> <span class="toc-text">leetcode 121. Best Time to Buy and Sell Stock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解法一"><span class="toc-number">2.1.</span> <span class="toc-text">解法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解法二"><span class="toc-number">2.2.</span> <span class="toc-text">解法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#leetcode121.best-time-to-buy-and-sell-stock-ii2"><span class="toc-number">3.</span> <span class="toc-text">leetcode121.Best Time to Buy and Sell Stock II</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">小舔哥</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">7</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">小舔哥</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">最大子数组和股票买卖问题</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-17</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/算法/">算法</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="最大子数组问题">最大子数组问题</h2>
<p>最大子数组问题：一个整数数组中的元素有正有负，在该数组中找出一个连续子数组，要求该连续子数组中各元素的和最大，并返回该最大值.</p>
<p>求解最大子数组问题用<strong>Kadane's algorithm</strong>。 卡登算法的思想是，给定一个数组A，假如我们已经知道了以数组第i个位置结尾的最大子数组为<span class="math inline">\(B_i\)</span>，那么在第i+1个位置结尾的最大子数组要么包含<span class="math inline">\(B_i\)</span>,要么不包含<span class="math inline">\(B_i\)</span>，如果将<span class="math inline">\(B\)</span>看作是动态规划当中的状态，那么状态转移方程是：$B_{i+1} = max (A_i, A_i + B_i) $</p>
<p>比如要计算数组 x = [-2, 1, -3, 4, -1, 2, 1, -5, 4] 的最大子数组，第一个位置的最大和为-2，第2个位置的最大和为max(1,-2+1) = 1,第三个位置最大和为max(-3,-3+1) = -2,那么依次类推，可以求出来以第i个位置结尾的最大和分别为 [0 , 1, -2, 4, 3, 5, 6, 1, 5]。</p>
<p>具体的算法是这样的： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_subarray</span><span class="params">(arr)</span>:</span></span><br><span class="line">    current_max_sum = max_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        current_max_sum = max(i, current_max_sum+i)</span><br><span class="line">        max_sum = max(current_max_sum, max_sum)</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="leetcode-121.-best-time-to-buy-and-sell-stock1">leetcode 121. <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a></h2>
<p>买卖股票的最佳时机</p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [7,1,5,3,6,4]<br>
输出: 5<br>
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [7,6,4,3,1]<br>
输出: 0<br>
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<h3 id="解法一">解法一</h3>
<p>直接将后一天的股票价格减去前一天的股票价格，表示第i-1天买入并且在第i天卖出获得的利润。然后求一个连续的利润，使得和最大，那么这个问题转换为求最大子数组问题。 比如对于[7,1,5,3,6,4]，用后一天的价格减去前一天的价格，并把第一天的值置为0，每天可以获得的利润为：[0,-6,4,-2,3,-2]</p>
<p>Python代码如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            prices[i] = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        max_profits = <span class="number">0</span></span><br><span class="line">        current_profits = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> prices[<span class="number">1</span>:]:</span><br><span class="line">            current_profits = max(current_profits+i, <span class="number">0</span>)</span><br><span class="line">            max_profits = max(max_profits, current_profits)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max_profits</span><br></pre></td></tr></table></figure></p>
<p>关于程序的说明： 对于程序的第13行，程序可以写为current_profits = max(current_profits+i, i)，这对于计算结果没问题，但是对于计算current_profits的值会有影响。试想一下当输入为[3,2,1]的时候,经过处理以后数组变为了[3,-1,-1]，那么current_profits，会计算出来-1，-1这样的值，但是这是不可能的，因为我们完全可以不买，使用0值就可以了，所以将这里替换为current_profits = max(current_profits+i, 0)，</p>
<h3 id="解法二">解法二</h3>
<p>将上面的代码优化一下，可以一遍来完成。<code>current_profits = max(0, current_profits+prices[i]-prices[i-1])</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_profits = <span class="number">0</span></span><br><span class="line">        current_profits = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            current_profits = max(<span class="number">0</span>, current_profits + prices[i] - prices[i<span class="number">-1</span>])</span><br><span class="line">            max_profits = max(max_profits, current_profits)</span><br><span class="line">        <span class="keyword">return</span> max_profits</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="leetcode121.best-time-to-buy-and-sell-stock-ii2">leetcode121.<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock II</a></h2>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [7,1,5,3,6,4]<br>
输出: 7<br>
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出,这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [1,2,3,4,5]<br>
输出: 4<br>
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出,这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
</blockquote>
<p>示例 3:</p>
<blockquote>
<p>输入: [7,6,4,3,1]<br>
输出: 0<br>
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<p>贪心算法走一波，贪心算法可以解决这个问题，只要当前的价格比昨天的价格高，那么就计算一次收益，最终的收益和就是能够获取的最大的收益。</p>
<p>Python代码如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            diff = prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> diff &gt; <span class="number">0</span>:</span><br><span class="line">                res += diff</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>参考： <a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane&#39;s_algorithm" target="_blank" rel="noopener">Maximum subarray problem 之 Kadane's algorithm</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小舔哥</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tiangexiao.github.io/2018/09/17/最大子数组/">https://tiangexiao.github.io/2018/09/17/最大子数组/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tiangexiao.github.io">小舔哥</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a><a class="post-meta__tags" href="/tags/动态规划/">动态规划</a><a class="post-meta__tags" href="/tags/贪心算法/">贪心算法</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2018/09/03/回溯法/"><span>回溯法</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2018 By 小舔哥</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>